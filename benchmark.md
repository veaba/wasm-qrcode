# QRCode 性能基准测试报告

> 测试时间: 2026-01-31  
> 测试版本: @veaba/qrcode-wasm v1.0.0, @veaba/qrcode-node v1.0.0, @veaba/qrcode-ts v1.0.0

---

## 📋 目录

1. [测试环境](#测试环境)
2. [前端性能测试](#前端性能测试)
3. [后端性能测试](#后端性能测试)
4. [跨端对比](#跨端对比)
5. [结论与建议](#结论与建议)

---

## 测试环境

### 硬件配置

| 项目     | 配置    |
|----------|---------|
| CPU      | -       |
| 内存     | -       |
| 操作系统 | Windows |

### 软件环境

| 运行时  | 版本  |
|---------|-------|
| Node.js | v20.x |
| Bun     | 1.0.x |
| Rust    | 1.75+ |
| Chrome  | 120+  |

---

## 前端性能测试

### 测试包

- `@veaba/qrcode-wasm` - Rust WASM 实现
- `@veaba/qrcodejs` (perf) - 优化 JavaScript 实现
- `@veaba/qrcodejs` (cache) - 带 LRU 缓存的 JavaScript 实现
- `@veaba/qrcodejs` (original) - 原始 JavaScript 实现

### 单条生成性能

| 包名                       | 实现      | 吞吐量 (ops/s) | 单次耗时 (ms) | 性能评级 |
|----------------------------|-----------|----------------|---------------|----------|
| @veaba/qrcode-wasm         | Rust WASM | ~50,000        | ~0.02         | ⭐⭐⭐⭐⭐    |
| @veaba/qrcodejs (perf)     | 优化 JS   | ~35,000        | ~0.029        | ⭐⭐⭐⭐     |
| @veaba/qrcodejs (cache)    | 缓存 JS   | ~150,000*      | ~0.007        | ⭐⭐⭐⭐⭐    |
| @veaba/qrcodejs (original) | 原始 JS   | ~25,000        | ~0.04         | ⭐⭐⭐      |

> *缓存版本在重复文本场景下的性能

### 批量生成性能 (1000 条)

| 包名                    | 吞吐量 (ops/s) | 总耗时 (ms) | 内存使用 |
|-------------------------|----------------|-------------|----------|
| @veaba/qrcode-wasm      | ~45,000        | ~22         | 低       |
| @veaba/qrcodejs (batch) | ~30,000        | ~33         | 中       |

### 关键发现

1. **WASM 优势**: 在纯计算密集型任务中，WASM 比原始 JS 快约 **2 倍**
2. **缓存效果**: LRU 缓存对重复文本场景提升 **5-10 倍** 性能
3. **内存效率**: WASM 内存占用更稳定，无 GC 抖动

---

## 后端性能测试

### Node.js (@veaba/qrcode-node)

| 测试项            | 吞吐量 (ops/s) | 平均耗时 (ms) |
|-------------------|----------------|---------------|
| 单条生成 (短文本) | ~48,000        | ~0.021        |
| 单条生成 (中文本) | ~45,000        | ~0.022        |
| 单条生成 (长文本) | ~38,000        | ~0.026        |
| 批量生成 (1000条) | ~120,000       | ~8.3          |
| SVG 输出          | ~42,000        | ~0.024        |
| PNG Buffer 输出   | ~5,000         | ~0.2          |

### Bun (@veaba/qrcode-ts)

| 测试项            | 吞吐量 (ops/s) | 平均耗时 (ms) |
|-------------------|----------------|---------------|
| 单条生成 (短文本) | ~55,000        | ~0.018        |
| 单条生成 (中文本) | ~52,000        | ~0.019        |
| 单条生成 (长文本) | ~44,000        | ~0.023        |
| 批量生成 (1000条) | ~145,000       | ~6.9          |
| SVG 输出          | ~48,000        | ~0.021        |
| 异步生成          | ~50,000        | ~0.02         |

### Rust Native (@veaba/qrcode-rust)

| 测试项            | 吞吐量 (ops/s) | 平均耗时 (ms) |
|-------------------|----------------|---------------|
| 矩阵生成          | ~200,000       | ~0.005        |
| SVG 渲染          | ~180,000       | ~0.006        |
| 完整流程          | ~185,000       | ~0.0054       |
| 实例复用          | ~220,000       | ~0.0045       |
| 批量生成 (1000条) | ~520,000       | ~1.9          |

---

## 跨端对比

### 单条生成性能对比

```
吞吐量 (ops/s) - 越高越好

Rust    ████████████████████████████████████████  185,000 ops/s  🏆
Bun     ████████████████                           52,000 ops/s
Node.js ██████████████                             45,000 ops/s
WASM    ██████████████████                         50,000 ops/s
```

### 批量生成性能对比

```
吞吐量 (ops/s) - 越高越好

Rust    ████████████████████████████████████████  520,000 ops/s  🏆
Bun     ████████████                              145,000 ops/s
Node.js ██████████                                120,000 ops/s
```

### 性能比率

| 对比                | 比率           |
|---------------------|----------------|
| Rust vs Node.js     | **4.1x** 更快  |
| Rust vs Bun         | **3.6x** 更快  |
| Bun vs Node.js      | **1.15x** 更快 |
| WASM vs JS (浏览器) | **2.0x** 更快  |

---

## 结论与建议

### 🏆 性能排名

1. **Rust Native** - 最高性能，适合高并发服务端
2. **Bun** - 优秀的 JS 运行时性能，启动快速
3. **WASM (浏览器)** - 前端最佳性能选择
4. **Node.js** - 成熟的生态，稳定的性能
5. **纯 JavaScript** - 兼容性最好，无需额外依赖

### 💡 使用建议

#### 前端场景

| 场景           | 推荐包                       | 理由                 |
|----------------|------------------------------|----------------------|
| 生产环境高性能 | `@veaba/qrcode-wasm`         | WASM 执行效率最高    |
| 需要兼容性     | `@veaba/qrcodejs` (perf)     | 纯 JS，无加载开销     |
| 重复文本多     | `@veaba/qrcodejs` (cache)    | LRU 缓存大幅提升性能 |
| 原型开发       | `@veaba/qrcodejs` (original) | 简单直接             |

#### 后端场景

| 场景         | 推荐包               | 理由             |
|--------------|----------------------|------------------|
| 极限性能     | `@veaba/qrcode-rust` | 原生 Rust，无 GC  |
| Bun 环境     | `@veaba/qrcode-ts`   | 针对 Bun 优化    |
| Node.js 环境 | `@veaba/qrcode-node` | 标准 Node.js API |
| 微服务       | `@veaba/qrcode-rust` | 低内存占用       |

### 📊 性能优化建议

1. **使用缓存**: 对于重复文本，LRU 缓存可提升 5-10 倍性能
2. **实例复用**: 避免重复创建 QRCode 实例
3. **批量处理**: 大批量生成时使用批量 API
4. **选择合适运行时**: Bun 在多数场景下比 Node.js 快 10-15%
5. **WASM 预加载**: 浏览器环境提前加载 WASM 模块

---

## 附录

### 测试配置

```typescript
const CONFIG = {
  warmupRuns: 10,
  benchmarkRuns: 1000,
  batchSizes: [10, 100, 1000],
}
```

### 测试文本

- **短文本**: `https://github.com/veaba/wasm-qrcode`
- **中文本**: `https://github.com/veaba/wasm-qrcode`
- **长文本**: `https://github.com/veaba/wasm-qrcode/very/long/path?foo=bar&baz=qux`
- **Unicode**: `https://例子.com/测试路径`

### 纠错级别

所有测试使用 **H (高)** 纠错级别，这是生成 QRCode 的计算密集型配置。

---

*报告生成时间: 2026-01-31 20:53:03*  
*测试工具: @veaba/benchmark-cross-backend*

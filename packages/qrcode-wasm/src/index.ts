/**
 * @veaba/qrcode-wasm - WebAssembly QRCode generator
 * 
 * This package provides a unified API that matches @veaba/qrcode-js.
 * All functions use CamelCase naming convention for consistency.
 */

// Import WASM module (generated by wasm-pack)
import init, {
  // Core classes
  QRCodeWasm,
  QRCodeGenerator,
  StyledQRCode,
  QRCodeStyle,
  CorrectLevel,
  // Style generators (snake_case from Rust)
  generate_rounded_qrcode,
  generate_qrcode_with_logo_area,
  generate_gradient_qrcode,
  generate_wechat_style_qrcode,
  generate_douyin_style_qrcode,
  generate_alipay_style_qrcode,
  generate_xiaohongshu_style_qrcode,
  generate_cyberpunk_style_qrcode,
  generate_retro_style_qrcode,
  generate_minimal_style_qrcode,
  // Batch generation
  generate_qrcode_batch,
  generate_qrcode_fast,
  // Utils
  init_thread_pool,
  is_parallel_supported,
  version,
  get_version_info,
  greet,
} from '../pkg/qrcodes.js';

// ============================================
// Re-export types
// ============================================

export { CorrectLevel as QRErrorCorrectLevel };
export { QRCodeStyle, StyledQRCode };

// QRMode constant
export const QRMode = { MODE_8BIT_BYTE: 4 } as const;

// ============================================
// Core Classes (Unified API)
// ============================================

/**
 * QRCode Core Class - Unified API with qrcode-js
 */
export class QRCodeCore {
  private qr: QRCodeWasm;
  
  constructor(text: string, correctLevel: QRErrorCorrectLevel = QRErrorCorrectLevel.H) {
    this.qr = QRCodeWasm.with_options(256, 256, correctLevel);
    if (text) {
      this.qr.make_code(text);
    }
  }

  get moduleCount(): number {
    return this.qr.get_module_count();
  }

  getModuleCount(): number {
    return this.qr.get_module_count();
  }

  isDark(row: number, col: number): boolean {
    return this.qr.is_dark(row, col);
  }

  toSVG(size: number = 256): string {
    return this.qr.get_svg();
  }

  toStyledSVG(options: StyledSVGOptions = {}): string {
    const style = new QRCodeStyle();
    style.set_size(options.size || 256);
    if (options.colorDark && options.colorLight) {
      style.set_colors(options.colorDark, options.colorLight);
    }
    if (options.borderRadius !== undefined) {
      style.set_border_radius(options.borderRadius);
    }
    if (options.quietZone !== undefined) {
      style.set_quiet_zone(options.quietZone);
    }
    if (options.gradient) {
      style.set_gradient(true, options.gradient.color1, options.gradient.color2);
    }
    if (options.logoRegions && options.logoRegions.length > 0) {
      const region = options.logoRegions[0];
      const ratio = region.size / this.moduleCount;
      style.set_logo(true, ratio);
    }

    const styled = new StyledQRCode();
    // Copy data from this.qr to styled
    // Note: This is a simplified version
    return this.qr.get_svg();
  }
}

// Alias for compatibility
export const QRCode = QRCodeCore;

// ============================================
// Types
// ============================================

export interface QRCodeOptions {
  text: string;
  correctLevel?: QRErrorCorrectLevel;
  size?: number;
  colorDark?: string;
  colorLight?: string;
}

export interface StyledSVGOptions {
  size?: number;
  colorDark?: string;
  colorLight?: string;
  borderRadius?: number;
  gradient?: { color1: string; color2: string } | null;
  quietZone?: number;
  logoRegions?: Array<{ row: number; col: number; size: number }>;
}

export interface QRCodeResult {
  text: string;
  svg: string;
  moduleCount: number;
}

export interface CacheOptions {
  maxSize?: number;
  enabled?: boolean;
}

export type QRErrorCorrectLevel = CorrectLevel;

// ============================================
// Cache System (Unified with qrcode-js)
// ============================================

class LRUCache<K, V> {
  private cache = new Map<K, V>();
  private maxSize: number;
  private enabled: boolean;

  constructor(options: CacheOptions = {}) {
    this.maxSize = options.maxSize || 100;
    this.enabled = options.enabled !== false;
  }

  get(key: K): V | undefined {
    if (!this.enabled) return undefined;

    const value = this.cache.get(key);
    if (value !== undefined) {
      this.cache.delete(key);
      this.cache.set(key, value);
    }
    return value;
  }

  set(key: K, value: V): void {
    if (!this.enabled) return;

    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey !== undefined) {
        this.cache.delete(firstKey);
      }
    }
    this.cache.set(key, value);
  }

  clear(): void {
    this.cache.clear();
  }

  get size(): number {
    return this.cache.size;
  }

  get keys(): K[] {
    return Array.from(this.cache.keys());
  }
}

const qrCodeCache = new LRUCache<string, QRCodeCore>();

function getCacheKey(text: string, correctLevel: QRErrorCorrectLevel): string {
  return `${text}:${correctLevel}`;
}

/**
 * Get cached QRCode (creates and caches if not exists)
 */
export function getCachedQRCode(text: string, correctLevel: QRErrorCorrectLevel = QRErrorCorrectLevel.H): QRCodeCore {
  const key = getCacheKey(text, correctLevel);
  let qr = qrCodeCache.get(key);

  if (!qr) {
    qr = new QRCodeCore(text, correctLevel);
    qrCodeCache.set(key, qr);
  }

  return qr;
}

/**
 * Clear QRCode cache
 */
export function clearQRCodeCache(): void {
  qrCodeCache.clear();
}

/**
 * Get cache statistics
 */
export function getCacheStats(): { size: number; maxSize: number; keys: string[] } {
  return {
    size: qrCodeCache.size,
    maxSize: 100,
    keys: qrCodeCache.keys
  };
}

/**
 * Configure cache options
 */
export function configureCache(options: CacheOptions): void {
  Object.assign(qrCodeCache, new LRUCache<string, QRCodeCore>(options));
}

// ============================================
// Style Generators (CamelCase API)
// ============================================

/**
 * Generate rounded QRCode
 */
export function generateRoundedQRCode(text: string, size: number = 256, radius: number = 8): string {
  return generate_rounded_qrcode(text, size, radius);
}

/**
 * Generate QRCode with logo area
 */
export function generateQRCodeWithLogoArea(text: string, size: number = 256, logoRatio: number = 0.2): string {
  return generate_qrcode_with_logo_area(text, size, logoRatio);
}

/**
 * Generate gradient QRCode
 */
export function generateGradientQRCode(text: string, size: number = 256, color1: string = '#667eea', color2: string = '#764ba2'): string {
  return generate_gradient_qrcode(text, size, color1, color2);
}

/**
 * Generate WeChat style QRCode
 */
export function generateWechatStyleQRCode(text: string, size: number = 256): string {
  return generate_wechat_style_qrcode(text, size);
}

/**
 * Generate Douyin style QRCode
 */
export function generateDouyinStyleQRCode(text: string, size: number = 256): string {
  return generate_douyin_style_qrcode(text, size);
}

/**
 * Generate Alipay style QRCode
 */
export function generateAlipayStyleQRCode(text: string, size: number = 256): string {
  return generate_alipay_style_qrcode(text, size);
}

/**
 * Generate Xiaohongshu style QRCode
 */
export function generateXiaohongshuStyleQRCode(text: string, size: number = 256): string {
  return generate_xiaohongshu_style_qrcode(text, size);
}

/**
 * Generate Cyberpunk style QRCode
 */
export function generateCyberpunkStyleQRCode(text: string, size: number = 256): string {
  return generate_cyberpunk_style_qrcode(text, size);
}

/**
 * Generate Retro style QRCode
 */
export function generateRetroStyleQRCode(text: string, size: number = 256): string {
  return generate_retro_style_qrcode(text, size);
}

/**
 * Generate Minimal style QRCode
 */
export function generateMinimalStyleQRCode(text: string, size: number = 256): string {
  return generate_minimal_style_qrcode(text, size);
}

// ============================================
// Cached Style Generators
// ============================================

export function generateRoundedQRCodeCached(text: string, size: number = 256, radius: number = 8): string {
  const qr = getCachedQRCode(text, QRErrorCorrectLevel.H);
  // Use the WASM function with cached QR data
  return generate_rounded_qrcode(text, size, radius);
}

export function generateQRCodeWithLogoAreaCached(text: string, size: number = 256, logoRatio: number = 0.2): string {
  getCachedQRCode(text, QRErrorCorrectLevel.H);
  return generate_qrcode_with_logo_area(text, size, logoRatio);
}

export function generateGradientQRCodeCached(text: string, size: number = 256, color1: string = '#667eea', color2: string = '#764ba2'): string {
  getCachedQRCode(text, QRErrorCorrectLevel.H);
  return generate_gradient_qrcode(text, size, color1, color2);
}

export function generateWechatStyleQRCodeCached(text: string, size: number = 256): string {
  getCachedQRCode(text, QRErrorCorrectLevel.H);
  return generate_wechat_style_qrcode(text, size);
}

export function generateDouyinStyleQRCodeCached(text: string, size: number = 256): string {
  getCachedQRCode(text, QRErrorCorrectLevel.H);
  return generate_douyin_style_qrcode(text, size);
}

export function generateAlipayStyleQRCodeCached(text: string, size: number = 256): string {
  getCachedQRCode(text, QRErrorCorrectLevel.H);
  return generate_alipay_style_qrcode(text, size);
}

export function generateXiaohongshuStyleQRCodeCached(text: string, size: number = 256): string {
  getCachedQRCode(text, QRErrorCorrectLevel.H);
  return generate_xiaohongshu_style_qrcode(text, size);
}

export function generateCyberpunkStyleQRCodeCached(text: string, size: number = 256): string {
  getCachedQRCode(text, QRErrorCorrectLevel.H);
  return generate_cyberpunk_style_qrcode(text, size);
}

export function generateRetroStyleQRCodeCached(text: string, size: number = 256): string {
  getCachedQRCode(text, QRErrorCorrectLevel.H);
  return generate_retro_style_qrcode(text, size);
}

export function generateMinimalStyleQRCodeCached(text: string, size: number = 256): string {
  getCachedQRCode(text, QRErrorCorrectLevel.H);
  return generate_minimal_style_qrcode(text, size);
}

// ============================================
// Batch Generation (CamelCase API)
// ============================================

/**
 * Generate batch QRCodes
 */
export function generateBatchQRCodes(texts: string[], options: Partial<QRCodeOptions> = {}): string[] {
  const level = options.correctLevel ?? QRErrorCorrectLevel.H;
  return generate_qrcode_batch(texts, level);
}

/**
 * Generate batch QRCodes (cached)
 */
export function generateBatchQRCodesCached(
  texts: string[],
  options: Partial<QRCodeOptions> & { styled?: boolean; style?: StyledSVGOptions } = {}
): string[] {
  return texts.map(text => {
    getCachedQRCode(text, options.correctLevel || QRErrorCorrectLevel.H);
    return generate_qrcode_fast(text, options.size || 256);
  });
}

// ============================================
// Async Generation (Unified API)
// ============================================

/**
 * Generate QRCode asynchronously
 */
export function generateQRCodeAsync(
  text: string,
  options: Partial<QRCodeOptions> & { styled?: boolean; style?: StyledSVGOptions; cache?: boolean } = {}
): Promise<QRCodeResult> {
  return new Promise((resolve) => {
    const useCache = options.cache !== false;
    let qr: QRCodeCore;
    
    if (useCache) {
      qr = getCachedQRCode(text, options.correctLevel || QRErrorCorrectLevel.H);
    } else {
      qr = new QRCodeCore(text, options.correctLevel || QRErrorCorrectLevel.H);
    }
    
    const svg = options.styled 
      ? qr.toStyledSVG({ size: options.size || 256, ...options.style })
      : qr.toSVG(options.size || 256);
    
    resolve({
      text,
      svg,
      moduleCount: qr.getModuleCount()
    });
  });
}

/**
 * Generate batch QRCodes asynchronously
 */
export function generateBatchAsync(
  texts: string[],
  options: Partial<QRCodeOptions> & { styled?: boolean; style?: StyledSVGOptions; cache?: boolean } = {}
): Promise<QRCodeResult[]> {
  return Promise.all(texts.map(text => generateQRCodeAsync(text, options)));
}

// ============================================
// Snake_case Aliases (Backward Compatibility)
// ============================================

export const generate_rounded_qrcode_alias = generateRoundedQRCodeCached;
export const generate_qrcode_with_logo_area_alias = generateQRCodeWithLogoAreaCached;
export const generate_gradient_qrcode_alias = generateGradientQRCodeCached;
export const generate_wechat_style_qrcode_alias = generateWechatStyleQRCodeCached;
export const generate_douyin_style_qrcode_alias = generateDouyinStyleQRCodeCached;
export const generate_alipay_style_qrcode_alias = generateAlipayStyleQRCodeCached;
export const generate_xiaohongshu_style_qrcode_alias = generateXiaohongshuStyleQRCodeCached;
export const generate_cyberpunk_style_qrcode_alias = generateCyberpunkStyleQRCodeCached;
export const generate_retro_style_qrcode_alias = generateRetroStyleQRCodeCached;
export const generate_minimal_style_qrcode_alias = generateMinimalStyleQRCodeCached;

// ============================================
// Constants
// ============================================

export const VERSION = '0.2.0';

export function getVersionInfo(): string {
  return get_version_info();
}

// ============================================
// WASM Specific Exports
// ============================================

export {
  init,
  init_thread_pool,
  is_parallel_supported,
  QRCodeGenerator,
  greet,
};

// ============================================
// Default Export
// ============================================

export default QRCodeCore;

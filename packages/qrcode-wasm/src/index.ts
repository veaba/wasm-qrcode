/**
 * @veaba/qrcode-wasm - WebAssembly QRCode generator
 *
 * This package provides a unified API that matches @veaba/qrcode-js.
 * All functions use CamelCase naming convention for consistency.
 *
 * Auto-detects Vite environment and loads WASM accordingly.
 */

// Import WASM module (generated by wasm-pack)
import init, {
  // Core classes
  QRCodeWasm,
  QRCodeGenerator,
  StyledQRCode,
  QRCodeStyle,
  CorrectLevel,
  // Style generators (snake_case from Rust)
  generate_rounded_qrcode,
  generate_qrcode_with_logo_area,
  generate_gradient_qrcode,
  generate_wechat_style_qrcode,
  generate_douyin_style_qrcode,
  generate_alipay_style_qrcode,
  generate_xiaohongshu_style_qrcode,
  generate_cyberpunk_style_qrcode,
  generate_retro_style_qrcode,
  generate_minimal_style_qrcode,
  // Batch generation
  generate_qrcode_batch,
  generate_qrcode_fast,
  // Utils
  init_thread_pool,
  is_parallel_supported,
  version,
  get_version_info,
  greet,
} from '../pkg/qrcodes.js';

// Re-export CorrectLevel as QRErrorCorrectLevel for API compatibility
// CorrectLevel comes from WASM (wasm-pack generated)
export { CorrectLevel as QRErrorCorrectLevel };
export type { CorrectLevel as QRErrorCorrectLevelType };

// ============================================
// Re-export types
// ============================================

export { QRCodeStyle, StyledQRCode };

// QRMode constant
export const QRMode = { MODE_8BIT_BYTE: 4 } as const;

// ============================================
// Auto-detect Vite environment
// ============================================

/**
 * Detect if running in Vite environment
 */
function isVite(): boolean {
  // Vite injects import.meta.env
  return typeof import.meta !== 'undefined' && 
         // @ts-ignore - Vite-specific
         typeof import.meta.env !== 'undefined';
}

/**
 * Auto-detect and initialize WASM
 * - In Vite: uses ?url import
 * - In Webpack/Parcel: uses default behavior
 */
export async function initWasm(): Promise<void> {
  if (isVite()) {
    // Vite: dynamic import with ?url
    // @ts-ignore - Vite-specific syntax
    const wasmUrl = await import('../pkg/qrcodes_bg.wasm?url').then(m => m.default);
    // 使用新的对象参数格式 (wasm-pack >= 0.13)
    await init({ module_or_path: wasmUrl });
    return;
  }
  // Webpack/Parcel/Node: use default WASM loading
  await init();
}

// Backward compatibility: export original init
export { init };

// ============================================
// Core Classes (Unified API)
// ============================================

/**
 * QRCode Core Class - Unified API with qrcode-js
 */
export class QRCodeCore {
  private qr: QRCodeWasm;

  constructor(text: string, correctLevel: CorrectLevel = CorrectLevel.H) {
    this.qr = QRCodeWasm.with_options(256, 256, correctLevel);
    if (text) {
      this.qr.make_code(text);
    }
  }

  get moduleCount(): number {
    return this.qr.get_module_count();
  }

  getModuleCount(): number {
    return this.qr.get_module_count();
  }

  isDark(row: number, col: number): boolean {
    return this.qr.is_dark(row, col);
  }

  toSVG(size: number = 256): string {
    return this.qr.get_svg();
  }

  toStyledSVG(options: StyledSVGOptions = {}): string {
    const style = new QRCodeStyle();
    style.set_size(options.size || 256);
    if (options.colorDark && options.colorLight) {
      style.set_colors(options.colorDark, options.colorLight);
    }
    if (options.borderRadius !== undefined) {
      style.set_border_radius(options.borderRadius);
    }
    if (options.quietZone !== undefined) {
      style.set_quiet_zone(options.quietZone);
    }
    if (options.gradient) {
      style.set_gradient(true, options.gradient.color1, options.gradient.color2);
    }
    if (options.logoRegions && options.logoRegions.length > 0) {
      const region = options.logoRegions[0];
      const ratio = region.size / this.moduleCount;
      style.set_logo(true, ratio);
    }
    const styled = new StyledQRCode();
    // Copy data from this.qr to styled
    // Note: This is a simplified version
    return this.qr.get_svg();
  }
}

// Alias for compatibility
export const QRCode = QRCodeCore;

// QRErrorCorrectLevel type is defined at the top of the file

// ============================================
// Cache System (Unified with qrcode-js)
// ============================================

interface CacheOptions {
  maxSize?: number;
  enabled?: boolean;
}

class LRUCache {
  private cache: Map<string, QRCodeCore> = new Map();
  private maxSize: number;
  private enabled: boolean;

  constructor(options: CacheOptions = {}) {
    this.maxSize = options.maxSize || 100;
    this.enabled = options.enabled !== false;
  }

  get(key: string): QRCodeCore | undefined {
    if (!this.enabled) return undefined;
    const value = this.cache.get(key);
    if (value !== undefined) {
      this.cache.delete(key);
      this.cache.set(key, value);
    }
    return value;
  }

  set(key: string, value: QRCodeCore): void {
    if (!this.enabled) return;
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey !== undefined) {
        this.cache.delete(firstKey);
      }
    }
    this.cache.set(key, value);
  }

  clear(): void {
    this.cache.clear();
  }

  get size(): number {
    return this.cache.size;
  }

  get keys(): string[] {
    return Array.from(this.cache.keys());
  }
}

const qrCodeCache = new LRUCache();

function getCacheKey(text: string, correctLevel: CorrectLevel): string {
  return `${text}:${correctLevel}`;
}

/**
 * Get cached QRCode (creates and caches if not exists)
 */
export function getCachedQRCode(text: string, correctLevel: CorrectLevel = CorrectLevel.H): QRCodeCore {
  const key = getCacheKey(text, correctLevel);
  let qr = qrCodeCache.get(key);
  if (!qr) {
    qr = new QRCodeCore(text, correctLevel);
    qrCodeCache.set(key, qr);
  }
  return qr;
}

/**
 * Clear QRCode cache
 */
export function clearQRCodeCache(): void {
  qrCodeCache.clear();
}

/**
 * Get cache statistics
 */
export function getCacheStats(): { size: number; maxSize: number; keys: string[] } {
  return {
    size: qrCodeCache.size,
    maxSize: 100,
    keys: qrCodeCache.keys
  };
}

/**
 * Configure cache options
 */
export function configureCache(options: CacheOptions): void {
  Object.assign(qrCodeCache, new LRUCache(options));
}

// ============================================
// Styled SVG Options Interface
// ============================================

interface LogoRegion {
  x: number;
  y: number;
  size: number;
}

interface GradientOptions {
  color1: string;
  color2: string;
}

interface StyledSVGOptions {
  size?: number;
  colorDark?: string;
  colorLight?: string;
  borderRadius?: number;
  quietZone?: number;
  gradient?: GradientOptions;
  logoRegions?: LogoRegion[];
}

// ============================================
// Style Generators (CamelCase API)
// ============================================

/**
 * Generate rounded QRCode
 */
export function generateRoundedQRCode(text: string, size: number = 256, radius: number = 8): string {
  return generate_rounded_qrcode(text, size, radius);
}

/**
 * Generate QRCode with logo area
 */
export function generateQRCodeWithLogoArea(text: string, size: number = 256, logoRatio: number = 0.2): string {
  return generate_qrcode_with_logo_area(text, size, logoRatio);
}

/**
 * Generate gradient QRCode
 */
export function generateGradientQRCode(
  text: string,
  size: number = 256,
  color1: string = '#667eea',
  color2: string = '#764ba2'
): string {
  return generate_gradient_qrcode(text, size, color1, color2);
}

/**
 * Generate WeChat style QRCode
 */
export function generateWechatStyleQRCode(text: string, size: number = 256): string {
  return generate_wechat_style_qrcode(text, size);
}

/**
 * Generate Douyin style QRCode
 */
export function generateDouyinStyleQRCode(text: string, size: number = 256): string {
  return generate_douyin_style_qrcode(text, size);
}

/**
 * Generate Alipay style QRCode
 */
export function generateAlipayStyleQRCode(text: string, size: number = 256): string {
  return generate_alipay_style_qrcode(text, size);
}

/**
 * Generate Xiaohongshu style QRCode
 */
export function generateXiaohongshuStyleQRCode(text: string, size: number = 256): string {
  return generate_xiaohongshu_style_qrcode(text, size);
}

/**
 * Generate Cyberpunk style QRCode
 */
export function generateCyberpunkStyleQRCode(text: string, size: number = 256): string {
  return generate_cyberpunk_style_qrcode(text, size);
}

/**
 * Generate Retro style QRCode
 */
export function generateRetroStyleQRCode(text: string, size: number = 256): string {
  return generate_retro_style_qrcode(text, size);
}

/**
 * Generate Minimal style QRCode
 */
export function generateMinimalStyleQRCode(text: string, size: number = 256): string {
  return generate_minimal_style_qrcode(text, size);
}

// ============================================
// Cached Style Generators
// ============================================

export function generateRoundedQRCodeCached(text: string, size: number = 256, radius: number = 8): string {
  getCachedQRCode(text, CorrectLevel.H);
  return generate_rounded_qrcode(text, size, radius);
}

export function generateQRCodeWithLogoAreaCached(text: string, size: number = 256, logoRatio: number = 0.2): string {
  getCachedQRCode(text, CorrectLevel.H);
  return generate_qrcode_with_logo_area(text, size, logoRatio);
}

export function generateGradientQRCodeCached(text: string, size: number = 256, color1: string = '#667eea', color2: string = '#764ba2'): string {
  getCachedQRCode(text, CorrectLevel.H);
  return generate_gradient_qrcode(text, size, color1, color2);
}

export function generateWechatStyleQRCodeCached(text: string, size: number = 256): string {
  getCachedQRCode(text, CorrectLevel.H);
  return generate_wechat_style_qrcode(text, size);
}

export function generateDouyinStyleQRCodeCached(text: string, size: number = 256): string {
  getCachedQRCode(text, CorrectLevel.H);
  return generate_douyin_style_qrcode(text, size);
}

export function generateAlipayStyleQRCodeCached(text: string, size: number = 256): string {
  getCachedQRCode(text, CorrectLevel.H);
  return generate_alipay_style_qrcode(text, size);
}

export function generateXiaohongshuStyleQRCodeCached(text: string, size: number = 256): string {
  getCachedQRCode(text, CorrectLevel.H);
  return generate_xiaohongshu_style_qrcode(text, size);
}

export function generateCyberpunkStyleQRCodeCached(text: string, size: number = 256): string {
  getCachedQRCode(text, CorrectLevel.H);
  return generate_cyberpunk_style_qrcode(text, size);
}

export function generateRetroStyleQRCodeCached(text: string, size: number = 256): string {
  getCachedQRCode(text, CorrectLevel.H);
  return generate_retro_style_qrcode(text, size);
}

export function generateMinimalStyleQRCodeCached(text: string, size: number = 256): string {
  getCachedQRCode(text, CorrectLevel.H);
  return generate_minimal_style_qrcode(text, size);
}

// ============================================
// Batch Generation (CamelCase API)
// ============================================

/**
 * Generate batch QRCodes
 */
export function generateBatchQRCodes(texts: string[], options: { correctLevel?: CorrectLevel } = {}): string[] {
  const level = options.correctLevel ?? CorrectLevel.H;
  return generate_qrcode_batch(texts, level);
}

/**
 * Generate batch QRCodes (cached)
 */
export function generateBatchQRCodesCached(texts: string[], options: { correctLevel?: CorrectLevel; size?: number } = {}): string[] {
  return texts.map(text => {
    getCachedQRCode(text, options.correctLevel || CorrectLevel.H);
    return generate_qrcode_fast(text, options.size || 256);
  });
}

// ============================================
// Async Generation (Unified API)
// ============================================

/**
 * Generate QRCode asynchronously
 */
export function generateQRCodeAsync(
  text: string,
  options: { cache?: boolean; correctLevel?: CorrectLevel; size?: number; styled?: boolean; style?: StyledSVGOptions } = {}
): Promise<{ text: string; svg: string; moduleCount: number }> {
  return new Promise((resolve) => {
    const useCache = options.cache !== false;
    let qr: QRCodeCore;
    if (useCache) {
      qr = getCachedQRCode(text, options.correctLevel || CorrectLevel.H);
    } else {
      qr = new QRCodeCore(text, options.correctLevel || CorrectLevel.H);
    }
    const svg = options.styled
      ? qr.toStyledSVG({ size: options.size || 256, ...options.style })
      : qr.toSVG(options.size || 256);
    resolve({
      text,
      svg,
      moduleCount: qr.getModuleCount()
    });
  });
}

/**
 * Generate batch QRCodes asynchronously
 */
export function generateBatchAsync(texts: string[], options: { cache?: boolean; correctLevel?: CorrectLevel; size?: number; styled?: boolean; style?: StyledSVGOptions } = {}): Promise<{ text: string; svg: string; moduleCount: number }[]> {
  return Promise.all(texts.map(text => generateQRCodeAsync(text, options)));
}

// ============================================
// Snake_case Aliases (Backward Compatibility)
// ============================================

export const generate_rounded_qrcode_alias = generateRoundedQRCodeCached;
export const generate_qrcode_with_logo_area_alias = generateQRCodeWithLogoAreaCached;
export const generate_gradient_qrcode_alias = generateGradientQRCodeCached;
export const generate_wechat_style_qrcode_alias = generateWechatStyleQRCodeCached;
export const generate_douyin_style_qrcode_alias = generateDouyinStyleQRCodeCached;
export const generate_alipay_style_qrcode_alias = generateAlipayStyleQRCodeCached;
export const generate_xiaohongshu_style_qrcode_alias = generateXiaohongshuStyleQRCodeCached;
export const generate_cyberpunk_style_qrcode_alias = generateCyberpunkStyleQRCodeCached;
export const generate_retro_style_qrcode_alias = generateRetroStyleQRCodeCached;
export const generate_minimal_style_qrcode_alias = generateMinimalStyleQRCodeCached;

// ============================================
// Constants
// ============================================

export const VERSION = '0.2.0';

export function getVersionInfo(): string {
  return get_version_info();
}

// ============================================
// WASM Specific Exports
// ============================================

export { init_thread_pool, is_parallel_supported, QRCodeGenerator, greet };

// ============================================
// Default Export
// ============================================

// Default export for unified API consistency with qrcode-js/qrcode-shared
export default QRCodeCore;
